---
title: C++设计模式（一）：工厂模式
date: 2016-05-21 17:35:16
categories: C++设计模式
tags: C++
---
## 一.什么是设计模式？
   如果要想完全的理解什么是设计模式，我们就需要对设计模式本身有一定的了解，那么，什么是设计模式呢？我们在进行一般的C++代码编程的时候，经常听到说，C++是一门面向对象的语言，要使用面向对象的方法，但是我们在实际操作的时候总会感到迷惑：面向对象究竟是什么样的？怎样才是有别于“结构化编程”的编程方法？

 那么，这个时候就轮到我们的主角设计模式登场了。

   所谓的设计模式，是一种代码经验的总结，它在编程中反复使用，保证代码的可靠性和可维护性。它让开发者能够更加好的复用成功的结构体系，也方便后面的开发者理解设计思路。
   现阶段，设计模式主要分为三个种类：创建性模式、结构型模式和行为型模式。

   今天我们要说的工厂模式，就是创建型模式的一种，也是开篇必讲的一种。
## 二.简单工厂模式
要想讲述工厂模式，我们一般都会从简单工厂模式开始讲起。
如果你要是被拜托制作一款系统应用于上班族的“刷脸”上班，你会怎么做？

啊，我看看，嗯....如果按照我们之前的想法，刷脸做一个类，然后把人脸识别、人脸特征提取、人脸相似度比对全都放进去，之后数据库上传和查询做一个类，然后让总体界面调用，但是如果过了一段时间，公司觉得刷脸还不够，因为有些家伙很狡猾，采取了一些手段蒙混过去了这个部分，所以公司觉得要在之前脸部注册的数据上在做些新功能。
这个时候你怎么办呢？
想必你肯定需要进入到刷脸的这个类里面去修改里面的方法和添加新的函数，这样一来就十分麻烦，代码的可维护性就相当的差。
或者像《大话设计模式》中所说，设计一个计算器，如果你将所有的加、减、乘、除都放在一个类里面，则在开发新功能的时候公司就不得不向你开放全部源码，这就是设计上的错误。

这个时候，工厂模式就发挥了作用。

工厂模式在开发系统的扩展功能方面颇有优势，而且可以轻松方便的构造对象实例，不用担心构造对方实例的复杂过程。

特点：提供创建对象的接口. 为系统结构提供了非常灵活强大的动态扩展机制，只要我们更换一下具体的工厂方法，系统其他地方无需一点变换，就有可能将系统功能进行改头换面的变化

而简单工厂模式，可以说是工厂模式的简化版本，下面我们通过一个案例来详细的分析一下：

我们还是使用之前说的计算器的案例吧，这个案例简单而且比较省事（所以关键是比较省事么....(笑)）
首先我们给出简单工厂模式的UML图：
![图0-0 简单工厂模式UML图](\images\C++designer\one_FactoryMode\简单工厂模式UML图.png)
如图所示，我们在图中总共有4个类，分别是工厂类Factory,还有计算类的父类Operation,继承它的子类sub和Dec(我就不把
加减乘除全写上了，大家知道就行。)
也就是说，用户不需要直接对计算类进行操作，用户只需要实例化一个工厂类的对象，然后调用工厂类中的CreateObject方法，就可以创建一个Operation的子类对象（当然，CreateObject()中的String参数是用来判断到底实例化的是哪一种子类对象，比如我
设定当传参数“Sub”时，就创建一个Sub类的对象）
举例如下：
```
Operation *CreateProject(string type)
	{
		if (type=="Sub")
		return new Sub();
		if (type == "Dec")
			return new Dec();
		return NULL;
	};
```
这样就会返回一个Opration 的子类对象，函数中的new 调用的是对应子类对象的构造函数。
之后只需这样调用，就能够得到结果：
```
	Factory* Test =  FactoryChild::Create();
   Operation *p1 = Test->CreateProject("Sub");
   p1->SetA(4);
   p1->SetB(8);
   cout<<p1->GetResult()<< endl;
```
此时我们可以得到输出，是12

这就是最简单的简单工厂模式，相信大家已经感受到他的好处，因为我们在开始开发扩展程序的时候，可以不在对原先已经成功的模块进行修改，这一编程方式符合C++编程中的**依赖倒转原则**
## 三.工厂模式
   说完了简单的，我们来看看更进一步的。
工厂模式，其实，工厂模式只是在简单工厂模式的基础上修改一些东西，你可能会问，为什么还要修改呢？刚刚的工厂模式看起来已经非常方便、还有什么必要再修改呢？
是的，简单工厂模式使我们在开发计算器的扩展程序的时候可以不用面对全部的、复杂的源码，而是直接开发集成到计算器的基类就可以了，
但是，在这个时候，我们仍不能满足，因为我们发现，它违背了C++编程中的**开闭原则**（所谓的“开放-封闭”原则就是开放接口，封闭修改）。即使是我们可以不用修改Operation类，我们却需要对Factory进行编辑，这仍然是一个不好的地方。
为了让工厂类也能够脱离这不舒服的修改模式，我们的工厂模式，闪亮登场了。
下面，我们照例贴出工厂模式的UML图，通过两张UML图的对比，我们可以清晰的看出两者的区别：
![图0-1 工厂模式UML图]( \images\C++designer\one_FactoryMode\工厂模式UML.png)
没错....看出区别了吗？其实我们就是对工厂类做了和Operate类一样的事情，我们将Factory类也抽象成了一个基类，当我们想要做什么的时候，我们就直接生成对应的工厂子类（比如SubFactory）,然后调用方法CreateProject()就会直接生成对应的Operation的子类（Sub）。
但是它还是有缺点。
**缺点：**增加运算类，会修改客户端代码，工厂方法只是把简单工厂的内部逻辑判断移到了客户端进行，每增加一个功能的类，就需要增加一个功能工厂，增加了额外的开发量。
下面，我们来说说最后一种：
## 四.抽象工厂模式
工厂模式总算是看起来像个样子了，但是还不够，老看计算器的问题有点腻了，我们来看看大人的生意吧！
我们来生产电脑配件吧！
但是我产出的电脑主机箱中的零件不只一种，要怎么办？
再来一个工厂？
不不不，你何必要浪费那个钱呢？
我们要把现有的工厂利用起来:
![图0-2 抽象工厂模式UML图](\images\C++designer\one_FactoryMode\抽象工厂模式.png)
希望你没被这张图晃花眼睛，实际上，我们确实是做到了将多个产品放到了一个工厂下面，这样的话你就可以生产出两个牌子的主板和Cpu了，我们在抽象工厂类中生成产品的时候，我们生成工厂子类并调用相应的产品方法，非常灵活。
我们能够在两个牌子中间进行切换，但是说实在的，修改客户端代码这部分还是逃不掉。
**优点：**易于切换，方便管理
**缺点：**还是需要修改客户端代码
## 五.附加内容
《大话设计模式》中对于这个部分有利用简单工厂模式进行一个改进：
![图0-3 抽象工厂模式改进UML图](\images\C++designer\one_FactoryMode\抽象工厂模式改进UML.png)
嘛，其实就是把之前的模式又用了回来而已。
那么我们现在总结一下：
简单工厂模式：
只有一个工厂类，且使用了判断语句。
违背开闭原则，较简单
工厂方法模式：
只有一个抽象产品类，可以派生出多个具体产品类。
 一个抽象工厂类，可以派生出多个具体工厂类。
每个具体工厂类只能创建一个具体产品类的实例。
抽象工厂模式：
多个抽象产品类，每个抽象产品类可以派生出多个具体产品类。
 一个抽象工厂类，可以派生出多个具体工厂类。
　 每个具体工厂类可以创建多个具体产品类的实例。
 区别：
工厂方法模式只有一个抽象产品类，而抽象工厂模式有多个。
工厂方法模式的具体工厂类只能创建一个具体产品类的实例，而抽象工厂模式可以创建多个。
简单工厂模式是工厂模式打破开闭原则的缩减版。
